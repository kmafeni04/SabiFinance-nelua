
local http = require ".vendor.http-nelua.http"
local datastar = require ".vendor.http-nelua.extras.datastar.datastar"
local norm = require ".vendor.norm.norm"
local nelt = require ".vendor.nelt.nelt"

local bcrypt = require ".utils.bcrypt"

local auth_controller = require ".controllers.auth"

require ".thirdparty.inline_map"


## if PROD then
-- postgres
## else
local db, err = norm.Db.new({
  kind = norm.DbKind.sqlite,
  conn = {
    sqlite = {
      name = "app.db"
    }
  }
})
local schema = norm.Schema
local type = schema.ColumnType

local err = norm.migrate(db, inline_map!(string, norm.Schema.MigrationFn, {
  ["1750497533"] = function(db: norm.Db): string
    local err = schema.create_table(db, "users", {
      { "id",       type.integer, { primary_key = true } },
      { "username", type.text, { unique = true } },
      { "email",    type.text, { unique = true } },
      { "password", type.text }
    })
    return err
  end,

  ["1750722036"] = function(db: norm.Db): string
    local _, err = db:insert("users", inline_map!(string, string, {
      username = "testuser",
      email = "test@test.com",
      password = bcrypt.encrypt("testpassword")
    }))
    return err
  end,

  ["1750890982"] = function(db: norm.Db): string
    local err = schema.create_table(db, "transactions", {
			{ "id",          type.integer, { primary_key = true } },
			{ "date",        type.text },
			{ "name",        type.text },
			{ "amount",      type.real },
			{ "type",        type.text },
			{ "description", type.text },
			{ "user_id",     type.integer },
		})
    return err
  end
}))
## end

local app = http.new({
  port = 8081
})

## if not PROD then
app.static_headers = inline_map!(string, string, {
  ["Cache-Control"] = ""
})
## end

local Users, err = norm.Model.new(&db, "users", "Users", {
  rels = {
    {
      kind = norm.RelationKind.has_many,
      rel = {
        name = "transactions",
        model_name = "Transactions",
      }
    }
  }
})
assert(err == "", err)

local Transactions, err = norm.Model.new(&db, "transactions", "Transactions", {
  rels = {
    {
      kind = norm.RelationKind.belongs_to,
      rel = {
        name = "user",
        model_name = "Users",
      }
    }
  }
})
assert(err == "", err)

app:get("index", "/", function(self: *http.Server): http.Response
  if self.session:get_val("current_user") ~= "" then
    return self:redirect(self:url_for("dashboard"))
  end
  local index = require ".templates.index-nelt"
  local tp: nelt.Template
  index(&tp, self)
  return self:html(http.Status.OK, tp:tostring())
end)

app:get("login", "/login", function(self: *http.Server): http.Response
  return auth_controller.login_get(self)
end)

app:post("login", "/login", function(self: *http.Server): http.Response
  return auth_controller.login_post(self, Users)
end)

app:get("signup", "/signup", function(self: *http.Server): http.Response
  return auth_controller.signup_get(self)
end)

app:post("signup", "/signup", function(self: *http.Server): http.Response
  return auth_controller.signup_post(self, Users)
end)

app:post("logout", "/logout", function(self: *http.Server): http.Response
  local err = self.session:set_val("current_user", "") 
  if err ~= "" then
    return self:error(err)
  end
  local err = self.session:set_val("current_user_id", "")
  if err ~= "" then
    return self:error(err)
  end
  local sseg, err = datastar.ServerSentEventGenerator.new(self)
  if err ~= "" then
    return self:error(err)
  end
  sseg:redirect(self:url_for("index"))
  return sseg.resp
end)

app:get("home", "/home", function(self: *http.Server): http.Response
  return self:redirect(self:url_for("dashboard"))
end)

app:get("dashboard", "/home/dashboard", function(self: *http.Server): http.Response
  local current_user = self.session:get_val("current_user")
  if current_user == "" then
    return self:redirect(self:url_for("login"))
  end
  local current_user_id = self.session:get_val("current_user_id")
  local dashboard = require ".templates.dashboard-nelt"
  local tp: nelt.Template
  local transactions, err = Transactions:select(inline_map!(string, string, {
    user_id = current_user_id
  }))
  if err ~= "" then
    return self:error(err)
  end
  tp.data = &transactions
  if tp.data == nilptr then 
    return self:error("")
  end 
  dashboard(&tp, self)
  return self:html(http.Status.OK, tp:tostring())
end)

-- FIX: I don't believe the way I'm handling errors is correct as the route is only called via datastar
app:post("transaction", "/transaction", function(self: *http.Server): http.Response
  local current_user_id = self.session:get_val("current_user_id")
  if current_user_id == "" then
    return self:error("Failed to determine current_user")
  end
  local sseg, err = datastar.ServerSentEventGenerator.new(self)
  if err ~= "" then
    return self:error(err)
  end
  local errors: sequence(string)
  local date = self.req.params["date"]
  if date == "" then
    errors:push("<li>Date is required</li>")
  end
  local date_match = date:match("%d%d%d%d%-%d%d%-%d%d")
  if not date_match then
    errors:push("<li>Malformed date</li>")
  end
  local name = self.req.params["name"]
  if name == "" then
    errors:push("<li>Name is required</li>")
  end
  if #name < 3 then
    errors:push("<li>Name must be 3 or more characters</li>")
  end

  local amount_number: number
  local amount = self.req.params["amount"]
  if not amount:match("^[%-+]?%d+%.?%d*$") then
    errors:push("<li>Malformed number amount</li>")
  else
    amount_number = tonumber(amount)
  end
  if amount_number <= 0 then
    errors:push("<li>Amount must be greater than 0</li>")
  end
  local type = self.req.params["type"]
  if type == "" then
    errors:push("<li>Name is required</li>")
  end
  if type ~= "Income" and type ~= "Expense" then
    errors:push("<li>Unknown transaction type</li>")
  end
  local description = self.req.params["description"]
  if #errors > 0 then
    sseg:merge_fragments(('<ul id="errors">%s</ul>'):format(string.concat(errors)))
  else
    local transaction, err = Transactions:create(inline_map!(string, string, {
			date = date,       
			name = name,       
			amount = amount,     
			type = type,       
			description = description,
			user_id = current_user_id,    
    }))
    if err ~= "" then
      sseg:merge_fragments('<ul id="errors"><li>Internal error occured</li></ul>')
      return sseg.resp
    end
    local transactions, err = Transactions:select(inline_map!(string, string, {
      user_id = current_user_id
    }))
    if err ~= "" then
      sseg:merge_fragments('<ul id="errors"><li>Internal error occured</li></ul>')
    else
      local transaction_income: number 
      local transaction_expenses: number 
      for _, transaction in ipairs(transactions) do 
        if transaction:get_col("type") == "Income" then 
          local num = transaction:get_col("amount") 
          transaction_income = transaction_income + tonumber(num) 
        elseif transaction:get_col("type") == "Expense" then 
          local num = transaction:get_col("amount") 
          transaction_expenses = transaction_expenses + tonumber(num) 
        end 
      end 

      sseg:merge_fragments('<ul id="errors"></ul>')
      local id = transaction:get_col("id")
      if id == "1" then
        sseg:merge_fragments(
          [[<table id="transactions_table">
              <style>
                me {
                  width: 100%;
                  border-collapse: collapse;
                  text-align: left;

                  & td {
                    padding-block-start: var(--padding-sm);
                  }
                }
              </style>
              <thead>
                <tr>
                  <th>Date:</th>
                  <th>Name:</th>
                  <th>Amount:</th>
                  <th>Type:</th>
                  <th>Desc:</th>
                  <th>Action:</th>
                </tr>
              </thead>
              <tbody id="transactions_table_body">
              </tbody>
            </table>]]
        )
      end
      local transaction_row = require ".templates.components.transaction-row-nelt" 
      local tp: nelt.Template
      transaction_row(
        &tp,
        id,
        date,
        name,
        tostring(amount_number), -- using amount_number to preserve the decimal point in case the returned value is a single digit
        type,
        description ~= "" and description or "-",
        self:url_for("transaction")
      )
      sseg:merge_fragments(tp:tostring(), {
        selector = "#transactions_table_body",
        merge_mode = datastar.FragmentMergeMode.Append
      })
      sseg:merge_signals((
        [[{ "popup": false, "transaction_income": %s, "transaction_expenses": %s }]]
      ):format(transaction_income, transaction_expenses))
    end
  end
  return sseg.resp
end)

-- FIX: I don't believe the way I'm handling errors is correct as the route is only called via datastar
app:delete("transaction", "/transaction", function(self: *http.Server): http.Response
  local current_user_id = self.session:get_val("current_user_id")
  if current_user_id == "" then
    return self:error("Failed to determine current_user")
  end

  local id = self.req.params["id"]
  if id == "" then
    return self:error()
  end

  local transaction, err = Transactions:find(inline_map!(string, string, {
    id = id
  }))
  if err ~= "" then
    return self:error(err)
  end

  local err = transaction:delete()
  if err ~= "" then
    return self:error(err)
  end

  local transactions, err = Transactions:select(inline_map!(string, string, {
    user_id = current_user_id
  }))
  if err ~= "" then
    return self:error(err)
  end

  local transaction_income: number 
  local transaction_expenses: number 
  for _, transaction in ipairs(transactions) do 
    if transaction:get_col("type") == "Income" then 
      local num = transaction:get_col("amount") 
      transaction_income = transaction_income + tonumber(num) 
    elseif transaction:get_col("type") == "Expense" then 
      local num = transaction:get_col("amount") 
      transaction_expenses = transaction_expenses + tonumber(num) 
    end 
  end 

  local sseg, err = datastar.ServerSentEventGenerator.new(self)
  if err ~= "" then
    return self:error(err)
  end

  sseg:execute_script(("document.getElementById('transaction_%s').remove()"):format(id))
  sseg:merge_signals(([[{ "transaction_income": %s, "transaction_expenses": %s }]]):format(transaction_income, transaction_expenses))
  if #transactions == 0 then
    local empty_transactions_table = require ".templates.fragments.empty-transactions-table-nelt"
    local tp: nelt.Template
    empty_transactions_table(&tp)
    sseg:merge_fragments(tp:tostring(), {
      selector = "#transactions_table",
    })
  end

  return sseg.resp
end)

app:get("goals", "/home/goals", function(self: *http.Server): http.Response
  if self.session:get_val("current_user") == "" then
    return self:redirect(self:url_for("login"))
  end
  local goals = require ".templates.goals-nelt"
  local tp: nelt.Template
  goals(&tp, self)
  return self:html(http.Status.OK, tp:tostring())
end)

app:get("profile", "/home/profile", function(self: *http.Server): http.Response
  if self.session:get_val("current_user") == "" then
    return self:redirect(self:url_for("login"))
  end
  local profile = require ".templates.profile-nelt"
  local tp: nelt.Template
  profile(&tp, self)
  return self:html(http.Status.OK, tp:tostring())
end)

app:serve()
